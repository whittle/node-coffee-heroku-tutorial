<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Node && CoffeeScript && Heroku]]></title>
  <link href="http://whittle.github.com/node-coffee-heroku-tutorial/atom.xml" rel="self"/>
  <link href="http://whittle.github.com/node-coffee-heroku-tutorial/"/>
  <updated>2011-10-20T23:38:44-04:00</updated>
  <id>http://whittle.github.com/node-coffee-heroku-tutorial/</id>
  <author>
    <name><![CDATA[Jason Whittle]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Headers and encodings: being a good web citizen]]></title>
    <link href="http://whittle.github.com/node-coffee-heroku-tutorial/blog/2011/10/19/headers-and-encodings-being-a-good-web-citizen/"/>
    <updated>2011-10-19T16:00:00-04:00</updated>
    <id>http://whittle.github.com/node-coffee-heroku-tutorial/blog/2011/10/19/headers-and-encodings-being-a-good-web-citizen</id>
    <content type="html"><![CDATA[<p>So, in the last post we sent our very first message, but we’re not
quite doing everything we should.</p>

<p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC 2616 §14.13</a>,
specifies that our server should be sending a <code>Content-Length</code> header
with the size of the body in octects (8-bit bytes). Fortunately,
Node can figure that out for us:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/8811e6c46aa910ad71420591548f1bb4aaa644eb/app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');

  var say_hello = function(request, response) {
    var message = 'Hello, world!';

    response.setHeader('Content-Type', 'text/plain; charset=utf-8');
    response.setHeader('Content-Length', Buffer.byteLength(message, 'utf8'));
    response.write(message, 'utf8');
    response.end();
  };

  var app = http.createServer(say_hello);
  app.listen(3080);
})();
</code></pre></noscript></div>


<p>Here, we used
<a href="http://nodejs.org/docs/v0.4.8/api/buffers.html#buffer.byteLength"><code>Buffer.byteLength()</code></a>
to measure the number of bytes that are going to be sent. We also made
it explicit that we wanted to do all of this in
<a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8</a>, although both <code>write()</code>
and <code>byteLength()</code> will default to UTF-8 if we specify nothing.</p>

<p>Because all of the characters in our <code>message</code> are in the ASCII
set—and can therefore be represented as single bytes in UTF-8—the
result of <code>byteLength()</code> in this case is the same as the result would
be for <code>message.length()</code>: 13. We can even prove this by including a
non-standard HTTP header:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/4344892c97c1f4cea0a04e188ba71baf5916b631/app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');

  var say_hello = function(request, response) {
    var message = 'Hello, world!';

    response.setHeader('Content-Type', 'text/plain; charset=utf-8');
    response.setHeader('Content-Length', Buffer.byteLength(message, 'utf8'));
    response.setHeader('X-Content-Character-Count', message.length);
    response.write(message, 'utf8');
    response.end();
  };

  var app = http.createServer(say_hello);
  app.listen(3080);
})();
</code></pre></noscript></div>


<p>However, if we include anything besides the first 128 characters of the Unicode
character set, <code>message.length()</code> will no longer give us the correct
result:</p>

<div><script src='https://gist.github.com/1299915.js?file=app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');

  var say_hello = function(request, response) {
    var message = 'مرحبا العالم';

    response.setHeader('Content-Type', 'text/plain; charset=utf-8');
    response.setHeader('Content-Length', Buffer.byteLength(message, 'utf8'));
    response.setHeader('X-Content-Character-Count', message.length);
    response.write(message, 'utf8');
    response.end();
  };

  var app = http.createServer(say_hello);
  app.listen(3080);
})();
</code></pre></noscript></div>


<p>Here, the usual English message has been switched with its
<a href="http://www.howtosayin.com/say/arabic/hello+world.html">Arabic equivalent</a>,
which has 12 characters that occupy 23 bytes on the wire, and the
headers bear that out:</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: text/plain; charset=utf-8
Content-Length: 23
X-Content-Character-Count: 12
Connection: keep-alive
</code></pre>

<p>Something important to note is the order that we’re calling methods on the
<a href="http://nodejs.org/docs/v0.4.12/api/http.html#http.ServerResponse"><code>http.ServerResponse</code></a>.
It is critical that all the headers have been set on the response
before ever calling
<a href="http://nodejs.org/docs/v0.4.12/api/http.html#response.write"><code>write()</code></a>,
because <code>write()</code> flushes the headers. Similarly,
<a href="http://nodejs.org/docs/v0.4.12/api/http.html#response.end"><code>end()</code></a>
signals that the headers and body are complete as is.</p>

<p>Constructing the response out-of-order is instructive, in that it
produces a number of distinct failure modes:</p>

<ul>
<li><p>Placing a <code>setHeader()</code> after a <code>write()</code> produces an exception with
the message “Can&#8217;t set headers after they are sent.” If the
exception is uncaught, it will crash the server.</p></li>
<li><p>Placing a <code>write()</code> after the <code>end()</code> causes that <code>write()</code> to never
get sent to the client.</p>

<ul>
<li>If the content-length header is too long for the actual content
sent (i.e., the <code>write()</code>s prior to the <code>end()</code>), the client will
stall as it waits for the server to send the missing bytes.</li>
</ul>
</li>
</ul>


<p>As we wrap things up, let’s shorten our code a little bit.
<a href="http://www.codinghorror.com/blog/2007/05/the-best-code-is-no-code-at-all.html">Much</a>
has
<a href="http://dev.af83.com/code-liability-not-asset-part-1-3/2010/02/24">been</a>
<a href="http://www.infoq.com/news/2011/05/less-code-is-better">said</a> about
keeping your code small, so I won’t harp on it:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/5a37ea31b0846e8ce72d853db43d2a38babb04e3/app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');

  var sayHello = function(request, response) {
    var message = 'Hello, world!';

    response.writeHead(200, {
      'Content-Type': 'text/plain; charset=utf-8',
      'Content-Length': Buffer.byteLength(message, 'utf8')});
    response.end(message, 'utf8');
  };

  var app = http.createServer(sayHello);
  app.listen(3080);
})();
</code></pre></noscript></div>


<p>What we’ve done here (besides going back to English and removing the
non-standard character-count header) is to pack our remaining headers
into an object and pass them all together to
<a href="http://nodejs.org/docs/v0.4.12/api/http.html#response.writeHead"><code>ServerResponse.writeHead()</code></a>.
<code>writeHead()</code> also requires an
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">HTTP status code</a>
which should always be <code>200 OK</code> for now.</p>

<p>Additionally, the documentation for
<a href="http://nodejs.org/docs/v0.4.12/api/http.html#response.end"><code>end()</code></a>
specifies that as well as finalizing our response, we can also use it
as a last (and in this case only) <code>write()</code>.</p>

<p>All told, this only saves us two method calls, but if every time you
refactor it nets huge gains, maybe you don’t do it enough.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Hello world: a first node app]]></title>
    <link href="http://whittle.github.com/node-coffee-heroku-tutorial/blog/2011/10/18/hello-world-a-first-node-app/"/>
    <updated>2011-10-18T15:02:00-04:00</updated>
    <id>http://whittle.github.com/node-coffee-heroku-tutorial/blog/2011/10/18/hello-world-a-first-node-app</id>
    <content type="html"><![CDATA[<p>As is traditional, we’re going to get started with a hello world app,
and we’re going to take it step-by-step.</p>

<p>First, we create a no-op node app. (No-op, noop, and nop are short for
no operation, which is an assembly-ish way of saying that this app
doesn’t do anything.) The initial version of that file is:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/db26a14ea44241edccb3f46e08e2a2a7a39600e9/app.js'></script>
<noscript><pre><code>(function() {
})();
</code></pre></noscript></div>


<p>What you see here is a common construction for executing code without
adding its constituent pieces to the global environment.</p>

<p>Once we have that local scope create, we can start adding things to it:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/453f1645b44c652811d13c0b1a196a1c7b72f7a6/app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');
})();
</code></pre></noscript></div>


<p>The <code>require()</code> function we’re using here is
<a href="http://nodejs.org/docs/v0.4.12/api/all.html#require">built into Node.js</a>,
although it isn’t a Node.js-specific invention. The <code>require()</code>
function is authoritatively described by
<a href="http://www.commonjs.org/">CommonJS’s</a> <a href="http://www.commonjs.org/specs/modules/1.0/">Modules
spec</a>, but the kernel of
it is: it takes a module identifier (e.g. <code>'http'</code>) and returns
everything the named module has exported (in this case, an object that
we’re storing into the <code>http</code> variable).</p>

<p>The reason we need the <code>http</code> module is so that we can do this:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/013450c96caabba3abeafdbccd75ec9b85ea91eb/app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');

  var app = http.createServer();
})();
</code></pre></noscript></div>


<p>The object exported by the
<a href="http://nodejs.org/docs/v0.4.12/api/all.html#hTTP"><code>http</code> module</a>
has a method called <code>createServer</code>, which creates an
<a href="http://nodejs.org/docs/v0.4.12/api/all.html#http.Server"><code>http.Server</code></a>,
of all things. We’re going to cleverly call the server that we just
summoned into existence <code>app</code>, despite this not being much of an app
yet.</p>

<p>All of the source we’ve looked at so far has been executable. If
you’ve been following along and typing it into your favorite text
editor, good job! I like the cut of your jib. If you haven’t, go ahead
and do it now. I’m going to assume that you’re using a file named
<code>app.js</code> for right now, just like I am.</p>

<p>Also, if you haven’t already installed Node, there are
<a href="https://github.com/joyent/node/wiki/Installation">plenty of ways to do it</a>,
although if you’re on a Mac, I would suggest
<a href="https://github.com/mxcl/homebrew">Homebrew</a>.</p>

<p>Once you have Node installed on your machine, you can start your app
from the directory you’re working in at any time by running <code>node
app.js</code>. When you try it with any of the previous files we’ve written
so far, however, nothing seems to happen. Node barely stops to think
before it returns you back to the console again. Where’s the server we
created?</p>

<p>The answer is that we created a server, but we didn’t tell it to do
anything; not even that we wanted it to accept connections. Let’s try
telling it just that:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/55e7733b635d0fd04addfd6ad292f5f12043c6b9/app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');

  var app = http.createServer();
  app.listen(3080);
})();
</code></pre></noscript></div>


<p>Here we’ve instructed the server we created to listen on port 3080 of
the machine that server is being run on. If you run <code>node app.js</code> now,
you’ll notice that instead of very quickly completing, now it seems to
do nothing but very slowly. In fact, it never returns at all, just
sitting there until you kill it (control-C in most Unix shells,
including the default shell on Macs).</p>

<p>The other thing you might notice about your new server is that, while
it’s running, your browser can try to connect to the sever at
<a href="http://localhost:3080">http://localhost:3080</a> but it also never
returns anything. So what we’ve created is exactly what it seems to
be: a server that listens, but never says anything back. Let’s dig
into that.</p>

<p>If you look at the
<a href="http://nodejs.org/docs/v0.4.12/api/all.html#http.createServer">API for the <code>http.createServer()</code></a>
call we’re making, you’ll see that we can pass it a <code>requestListener</code>,
which is “a function which is automatically added to the &#8216;request&#8217;
event.” That sounds just like what we’re looking for:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/dc8ad3b70bc79cd3b046f3aac7530907fbe661c1/app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');

  var say_nothing = function() {};

  var app = http.createServer(say_nothing);
  app.listen(3080);
})();
</code></pre></noscript></div>


<p>If you run this version of app.js, you’ll find that the behavior of
our server hasn’t changed at all: it still never returns
anything. Digging into the Node API again, we see that the signature
of <code>http.Server</code>’s <code>request</code> event (which you’ll recall is the event
to which <code>createServer</code> attaches the function you give it) is
<code>function (request, response) { }</code>.</p>

<p>A little more digging in
<a href="http://nodejs.org/docs/v0.4.12/api/all.html#http.ServerResponse"><code>http.ServerResponse</code></a>
nets us this gem: “The method, <code>response.end()</code>, MUST be called on
each response.” Let’s put this to work for us by changing
<code>say_nothing()</code>’s parameters to match <code>http.Server</code>’s <code>request</code> event
and calling <code>end()</code> on the <code>ServerResponse</code> we just exposed:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/cc5158d5dbede2d368a043dbb5fd7616d7206cfd/app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');

  var say_nothing = function(request, response) {
    response.end();
  };

  var app = http.createServer(say_nothing);
  app.listen(3080);
})();
</code></pre></noscript></div>


<p>Once you have this app running, you can finally connect to it with
your web browser at
<a href="http://localhost:3080">http://localhost:3080</a>. The server returns a
blank page, but at least it doesn’t just spin forever.</p>

<p>What can we do from here? Anything we want, really: we now have a
working web server. But, as I mentioned in the beginning, I’m a
traditionalist and so we’re going to continue in the direction of
“Hello, world!”</p>

<p>The HTTP server that Node provides us with is intentionally low-level
and depends on us to fill in all of the details. Later on, we’ll find
ways to encapsulate this low-level behavior in a declarative,
functional matter, but for right now we’re going to have to do things
like set the response headers ourselves.</p>

<p>When I run this little non-app, the headers I see on the empty
response are:</p>

<pre><code>HTTP/1.1 200 OK
Connection: keep-alive
Transfer-Encoding: chunked
</code></pre>

<p>(You can see the headers too, if you use Chrome’s
<a href="http://code.google.com/chrome/devtools/docs/overview.html">Developer Tools</a>
or <a href="http://getfirebug.com/">Firebug</a> for Firefox.)</p>

<p>The next crucial header we’re going to need to get our hello through
properly is the content type:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/93ffcbff2abaa009fa281a02e0e18668d79e8537/app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');

  var say_nothing = function(request, response) {
    response.setHeader('Content-Type', 'text/plain');
    response.end();
  };

  var app = http.createServer(say_nothing);
  app.listen(3080);
})();
</code></pre></noscript></div>


<p>According to
<a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html">RFC 2616 §14.17</a>,
the Content-Type header “indicates the media type of the entity-body
sent to the recipient,” or in this case just lets the browser know
that we’re sending it plaintext. If you inspect the (still empty)
response that you get from your node server now, you’ll see headers
like:</p>

<pre><code>HTTP/1.1 200 OK
Content-Type: text/plain
Connection: keep-alive
Transfer-Encoding: chunked
</code></pre>

<p>Now that we let the browser know what we’re sending, we’re ready to
send that famous first message:</p>

<div><script src='http://gist-it.appspot.com/github/whittle/node-coffee-heroku-tutorial/raw/7bab5c62f53857fbfd6487e77eaaaf906c7c04e0/app.js'></script>
<noscript><pre><code>(function() {
  var http = require('http');

  var say_hello = function(request, response) {
    var message = 'Hello, world!';

    response.setHeader('Content-Type', 'text/plain');
    response.write(message);
    response.end();
  };

  var app = http.createServer(say_hello);
  app.listen(3080);
})();
</code></pre></noscript></div>


<p>Fire up your node server and <a href="http://localhost:3080">check it out</a>!</p>
]]></content>
  </entry>
  
</feed>
